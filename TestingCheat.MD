# PYTHON DJANGO TESTING CHEAT-CHEAT ğŸ’­ğŸ’­

### ğŸ–‡ï¸ We Test Behaviours, Not Implementation

## ğŸ“Œ Introduction To Testing
### ğŸ—ï¸ Need for Testing:
    âœ”ï¸ Quality Assurance:  Ensure the application works as expecte
    âœ”ï¸ Bug Identification:  Detect and fix bugs early in the development cycle
    âœ”ï¸ Code Maintenance:  Facilitate Code refactoring enhancements with confident
    âœ”ï¸ Documentation:  Tests Servers as additional Documentation for the code Base
    âœ”ï¸ Automated Verification:  Reduce manual efforts with automated test cases.

### ğŸ–ï¸ Best Practices:
    âœ”ï¸ Write Testable Code:  Ensure your code is modular and loosely coupled to make
    it easier to test.
    âœ… Use  Test-Driven Development (TDD):  Write tests before writing the actual code.
    âœ”ï¸ Keep It Simple:  Write Simple and readable test cases.
    âœ… Test Coverage: Aim for high test coverage but focus on **Critical & Complex parts**.
    âœ”ï¸ Use Fixtures: Use setup and teardown methods to prepare the test Environment.
    âœ”ï¸ Mock External Services: Use mocking for external services and APIs to avoid dependencies
    âœ”ï¸ Continuous Integration(CI): Integrate tests with CI tools and run tests automatically on code changes.

### Automated Testing Encompasses: 
1. Unit Testing
2. Performance Testing
3. Profiling & Optimization

## 1. Unit Testing.
âœ…"pytest" is a testing framework for Python that makes it easy to write simple and scalable test cases. It is particulary popular for its simplicity and ease of use.

### â˜£ï¸ â˜£ï¸ Installation
~~~
conda install pytest pytest-django
pip install pytest pytest-django
~~~



### ğŸ”ŒğŸ”Œ Configuration
- Create a "pytest.ini" file in the root directory of your Django project:
~~~
[pytest]
DJANGO_SETTINGS_MODULE = your-project-name.settings
python_files = tests.py test_*.py *_tests.py
~~~
âœ… Ensure your Django settings module is set correctly.


### ğŸ”‹ğŸ”‹Writing Tests:
âœ… Create a test File (i.e "test_models.py") in your app's "tests" directory.

Example:
~~~
import pytest
from myapp.models import MyModel

@pytest.mark.django_db
def test_my_model_creation():
    instance = MyModel.objects.create(name="Test")
    assert instance.name == "Test"
~~~

### ğŸš€ğŸš€ Running Tests:
~~~
pytest
~~~


## 2. Performance Testing.
âœ… "Locust" is an open-source load testing tool that allows you to define user behavior using Python Code. Its used to test the performance of web applications.

### â˜£ï¸ â˜£ï¸  Installation:
~~~
conda install locust
pip install locust
~~~

### ğŸ”ŒğŸ”Œ Configuration:
âœ…  Create a "locustfile.py" in your project directory.
âœ…  Define User behavior and tasks

### ğŸ“ŠğŸ“Š Example:
~~~
from locust import HttpUser, TaskSet, task, between

class UserBehavior(TaskSet):
    @task(1)
    def index(self):
        self.client.get("/")

    @task(2)
    def about(self):
        self.client.get("/about/")

class WebsiteUser(HttpUser):
    tasks = [UserBehavior]
    wait_time = between(5, 15)
~~~

### ğŸš€ğŸš€ Running Tests:
~~~
locust -f locustfile.py
~~~
âœ… Open Browser and go to "http://localhost:8089" to start the test.

## 3. Profiling and Optimization
âœ…  "Silk" is a Django App for profiling and inspecting SQL queries. It helps in identifying performance bottlenecks and optimizing your Django Application.

### â˜£ï¸ â˜£ï¸  Installation:
~~~
pip install django-silk

conda install django-silk
~~~

### ğŸ”ŒğŸ”Œ Configuration:
âœ… Add "silk" to your "INSTALLED_APPS" in "settings.py":
~~~
INSTALLED_APPS = [
    ...
    'silk',
]
~~~
âœ… Add "SilkMiddlware" to "MIDDLEWARE":
~~~
MIDDLEWARE = [
    ...
    'silk.middleware.SilkyMiddleware',
]
~~~
âœ… Configure the url pattern for silk:
~~~
urlpatterns += [path("silk/", include("silk.urls", namespace="silk"))]
~~~

âœ… Run Migrations
~~~ 
python manage.py migrate silk
~~~

### ğŸ“ŠğŸ“Š Usage:
- Start Django Server.
- Go to "/silk/" to access the Silk Profiling Interface.


## ğŸ´â€â˜ ï¸ğŸ´â€â˜ ï¸ Summary
- By using pytest for unit testing, Locust for performance testing, and Silk for profiling and optimization, you can ensure your Django application is well-tested, performs efficiently under load, and is optimized for performance.